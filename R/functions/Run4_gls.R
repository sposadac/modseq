Run4_gls <- function(patterns, mod.comb, res.listName, res.list=NULL,  
                     res.list.ids=NULL, res.list.lengths=NULL,  out.filename, 
                     modseq.dir=NULL, out.dir=NULL, num.cores=numeric(0)) {
  
  ## Function arguments
  # patterns      Complete path to the csv file (table of modules).
  # res.listName  Autogenerated name for output files or name of the R object  
  #               storing the list of results from the read mapping (without 
  #               the file extension).
  # modseq.dir    (optional) modseq's head directory, by default current working
  #               directory.
  # out.dir       (optional) Path to output files.
  # num.cores     (optional) number of cores available for performing parallel 
  #               tasks.
  
  ## Whenever modseq path or output directory are not specified, assumed to be 
  #  the current working directory
  if (is.null(modseq.dir)) {
    modseq.dir <- getwd()
    warning("Object \'modseq.dir\' not found, set to: \"", modseq.dir, "\".")
  } 
  if (is.null(out.dir)) {
    out.dir <- getwd()
  }
  
  if (length(num.cores) == 0) {
    num.cores <- detectCores()
  }
  
  if (!existsFunction("VariantFrequencies")) {
    source(file.path(modseq.dir, "R/functions/VariantFrequencies.R"))
  }
  if (!existsFunction("PlotModuleCombinationsDistribution")) {
    source(
      file.path(modseq.dir, "R/functions/PlotModuleCombinationsDistribution.R"))
  }
  
  ## Loading res.list (results from read mapping)
  if (is.null(res.list)) { 
    in.file <- 
      file.path(out.dir, paste("resList_", res.listName, ".rda", sep = ""))
    if (file.exists(in.file)) {
      load(in.file)
    } else {
      in.file <- file.path(out.dir, paste(res.listName, ".rda", sep = ""))
      if (file.exists(in.file)) {
        load(in.file)
      } else {
        stop("File \"", in.file, "\" not found. \n")
      }
    }
    cat("Loading list of read-mapping hits: \"", in.file, "\".\n", sep = "")
  }
  
  mod.comb.len <- length(mod.comb)
  
  ##### 1: Output table 
  # Displaying the reference sequence to which each read was mapped.
  if (is.null(res.list.lengths) || is.null(res.list.ids)) {
    
    if (!existsFunction("ParseInfoResultsList")) {
      source(file.path(modseq.dir, "R/functions/ParseInfoResultsList.R"))
    }
    retList <- 
      ParseInfoResultsList(res.list = res.list, mod.comb = mod.comb, 
                           mod.comb.len = mod.comb.len, num.cores = num.cores)
    res.list.lengths <- retList[[1]]
    res.list.ids <- retList[[2]]
    
  }
  
  res.list.seq <- 
    unlist(mcmapply(function (x,n) rep(x,n), x = names(res.list),
                    n = res.list.lengths, USE.NAMES = FALSE, 
                    mc.cores = num.cores), use.names = FALSE)
  
  out.table <- data.frame("Read ID" = unlist(res.list, use.names = FALSE),
                          "Reference ID" = res.list.ids, 
                          "Reference sequence" = res.list.seq,
                          stringsAsFactors = FALSE)
  out.file <- 
    file.path(out.dir, 
              paste(res.listName, "_readMapping_table.csv", sep = ""))
  cat("Exporting: \"", out.file, "\" ... \n", sep = "")
  write.csv(out.table, file = out.file)
  
  ###### 2: Last search round: Distribution of modular variants
  ## Number of hits per modular variant in the last search round
  VariantFrequencies(
    data = res.list.ids, patterns = patterns, 
    num.hits = length(unlist(res.list)), out.filename = out.filename,
    modseq.dir = modseq.dir, out.dir = out.dir, num.cores = num.cores
    )
  
  ##### 3: Distribution of module combinations
  mod.dstr <- sort(res.list.lengths, decreasing = TRUE)
  df.mod.dstr <- data.frame("x" = seq_len(mod.comb.len) * 100 / mod.comb.len, 
                            "y" = mod.dstr)
  
  out.file <- 
    file.path(out.dir, 
              paste(out.filename, "_ModComb_distribution_graph.pdf", sep = ""))
  cat("Plotting distribution of module combinations: \"", out.file, "\". \n", 
      sep = "")

  PlotModuleCombinationsDistribution(data = df.mod.dstr, x.var = "x", 
                                     y.var = "y", out.file = out.file)
  

}
